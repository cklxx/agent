# SPDX-License-Identifier: MIT

"""
Workflow for generating writing inspiration, orchestrating planning and agent execution.
"""

import logging
from typing import Dict, Any, List, Optional

# Agent and Planner imports
from src.agents.writing_task_planner import WritingTaskPlanner
from src.agents.inspiration_agent import create_inspiration_agent

# Tool imports
from src.tools.writing_tools import (
    get_current_datetime,
    generate_random_inspiration_theme,
    save_content_to_file,
    list_saved_content,
    generate_character_elements,
    generate_plot_outline_elements,
)
from src.tools.search import get_web_search_tool # Example of including a general tool

# Setup logger for this module
logger = logging.getLogger(__name__)


class WritingInspirationWorkflow:
    """
    Orchestrates the process of generating writing inspiration.
    This involves planning the task and then executing the plan with an inspiration agent.
    """

    def __init__(self):
        """Initializes the workflow, setting up the planner, tools, and agent."""
        self.logger = logging.getLogger(self.__class__.__name__)
        self.logger.info("Initializing Writing Inspiration Workflow...")

        self.planner = WritingTaskPlanner()
        self.logger.info("Writing Task Planner initialized.")

        self.writing_tools: List[Any] = [
            get_current_datetime,
            generate_random_inspiration_theme,
            save_content_to_file,
            list_saved_content,
            generate_character_elements,
            generate_plot_outline_elements,
            get_web_search_tool(), # Instantiate if it's a function returning a tool
        ]
        self.logger.info(f"Loaded {len(self.writing_tools)} writing tools.")
        tool_names = [getattr(tool, "name", str(tool)) for tool in self.writing_tools]
        self.logger.debug(f"Available tools: {', '.join(tool_names)}")


        self.agent = create_inspiration_agent(tools=self.writing_tools)
        self.logger.info("Inspiration Agent created and configured.")

    async def execute_task(self, task_description: str, max_iterations: int = 5) -> Dict[str, Any]:
        """
        Executes a creative writing task by planning it and then running an agent on the plan.

        Args:
            task_description: The user's request or description of the creative task.
            max_iterations: The maximum number of iterations for the agent per step.

        Returns:
            A dictionary containing the results of the task execution, including the plan
            and the outcomes of each step.
        """
        self.logger.info(f"Starting creative writing task: {task_description[:100]}...")
        final_results: Dict[str, Any] = {
            "task_description": task_description,
            "plan": [],
            "step_outputs": [],
            "summary": "",
            "errors": []
        }

        try:
            # 1. Plan the task
            self.logger.debug("Planning the writing task...")
            planned_steps = self.planner.plan_task(task_description)
            final_results["plan"] = planned_steps

            if not planned_steps:
                self.logger.warning("No steps were generated by the planner.")
                final_results["summary"] = "Task planning did not produce any steps."
                return final_results

            self.logger.info(f"Task planned into {len(planned_steps)} steps.")

            # 2. Iterate through steps and execute with the agent
            for i, step in enumerate(planned_steps):
                step_title = step.get('title', f'Step {i+1}')
                step_description = step.get('description', 'No description provided for this step.')
                self.logger.info(f"Executing step {i+1}/{len(planned_steps)}: {step_title}")
                self.logger.debug(f"Step description: {step_description}")

                # Prepare input for the ReAct agent
                # The inspiration_agent_react_prompt expects "task_description" and "locale" (optional)
                # It also handles "available_tools", "previous_attempts", "scratchpad" internally via state.
                agent_input = {
                    "messages": [("user", f"Current task: {step_title}. Details: {step_description}")],
                    # "locale": "en-US" # Example: you might want to pass this from higher up
                }

                step_output_record = {
                    "step_id": step.get("id"),
                    "step_title": step_title,
                    "step_description": step_description,
                    "agent_response_content": None,
                    "error": None
                }

                try:
                    # Invoke the agent for the current step
                    # The recursion_limit in config is important for ReAct agents
                    agent_response = await self.agent.ainvoke(agent_input, config={"recursion_limit": max_iterations})

                    # Extract the final response content
                    # For ReAct agents, this is typically the last message, often from AIMessage
                    if agent_response and "messages" in agent_response and agent_response["messages"]:
                        # The actual content might be in agent_response['messages'][-1].content
                        # or agent_response['output'] depending on create_react_agent version and usage.
                        # Let's assume it's in the last message's content.
                        last_message = agent_response["messages"][-1]
                        response_content = getattr(last_message, 'content', str(last_message))
                        step_output_record["agent_response_content"] = response_content
                        self.logger.info(f"Step '{step_title}' completed.")
                        self.logger.debug(f"Agent response preview for step '{step_title}': {response_content[:150]}...")
                    else:
                        self.logger.warning(f"No messages found in agent response for step '{step_title}'. Response: {agent_response}")
                        step_output_record["error"] = "Agent returned no messages in response."
                        final_results["errors"].append(f"Step '{step_title}': Agent returned no messages.")

                except Exception as agent_exc:
                    self.logger.error(f"Error during agent execution for step '{step_title}': {agent_exc}", exc_info=True)
                    step_output_record["error"] = str(agent_exc)
                    final_results["errors"].append(f"Step '{step_title}': {str(agent_exc)}")

                final_results["step_outputs"].append(step_output_record)

            final_results["summary"] = f"Successfully processed {len(planned_steps)} steps."
            if final_results["errors"]:
                final_results["summary"] += f" Encountered {len(final_results['errors'])} error(s)."

        except Exception as e:
            self.logger.error(f"An error occurred during writing inspiration workflow execution: {e}", exc_info=True)
            final_results["summary"] = "Workflow execution failed."
            final_results["errors"].append(f"Overall workflow error: {str(e)}")

        self.logger.info(f"Writing inspiration task finished for: {task_description[:100]}...")
        return final_results


async def run_writing_inspiration_workflow(task_description: str, max_iterations: int = 5) -> Dict[str, Any]:
    """
    Runs the complete writing inspiration workflow for a given task description.

    Args:
        task_description: The user's request or description of the creative task.
        max_iterations: The maximum number of iterations for the agent per step.

    Returns:
        A dictionary containing the results of the task execution.
    """
    logger.info(f"Initiating writing inspiration workflow for: {task_description[:100]}")
    workflow_instance = WritingInspirationWorkflow()
    results = await workflow_instance.execute_task(task_description, max_iterations)
    logger.info(f"Writing inspiration workflow completed for: {task_description[:100]}")
    return results


if __name__ == '__main__':
    import asyncio

    # Configure basic logging for testing
    logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    async def main_test():
        logger.info("--- Starting Writing Inspiration Workflow Test ---")

        # Test Case 1: A simple request
        # This test requires actual LLM calls and prompt availability.
        # It might be slow and cost tokens.
        # test_task_1 = "Generate ideas for a fantasy character who is a reluctant hero."
        # results_1 = await run_writing_inspiration_workflow(test_task_1, max_iterations=3)
        # print("\n--- Results for Test Task 1 ---")
        # print(json.dumps(results_1, indent=2, default=str)) # Use default=str for any non-serializable objects

        # Test Case 2: A request that might use specific tools
        test_task_2 = "Create a character profile for a sci-fi detective and save it to a file. Also, suggest a random theme for their first case."
        # To make this testable without full LLM setup, one might need to mock planner/agent or ensure prompts are very robust to simple LLMs if using basic ones.
        # For now, this will run if environment is set up.
        try:
            results_2 = await run_writing_inspiration_workflow(test_task_2, max_iterations=5) # Increased iterations as it's more complex
            print("\n--- Results for Test Task 2 ---")
            import json # Ensure json is imported for the test output
            print(json.dumps(results_2, indent=2, default=str))
        except Exception as e:
            print(f"Error during Test Task 2: {e}")
            logger.error("Error in main_test during Test Task 2", exc_info=True)


        logger.info("--- Writing Inspiration Workflow Test Finished ---")

    # Python 3.7+
    asyncio.run(main_test())
```
